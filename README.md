# Data Structures and Algorithms Repository

Welcome to my Data Structures and Algorithms (DSA) repository!

I recently started learning DSA and will be adding the code for the problems I solve in this repository. You’ll find solutions primarily in JavaScript, and occasionally in Python, as I continue to improve my skills.

## Overview

### Algorithm Design Techniques
- **Brute Force**: Tries all possible solutions until the correct one is found. Simple but often inefficient.

- **Greedy Algorithm**: This approach makes the best choice at each step, hoping that these local best choices will lead to a global best solution. It’s like always picking the quickest or cheapest option available without worrying about future consequences.

- **Divide and Conquer**: Breaks the problem into smaller sub-problems, solves each one independently, and combines the results.

- **Dynamic Programming (DP)**: Solves complex problems by breaking them down into simpler sub-problems, storing the results of solved sub-problems to avoid redundant calculations.

- **Backtracking**: This is a problem-solving technique that explores all possible solutions by building them step by step. If a step leads to a solution that doesn't work, it "backs up" and tries a different option.

### 1) Time Complexity
Time complexity is a computational concept that describes the amount of time an algorithm takes to complete as a function of the length of the input. It's generally expressed using Big O notation, which classifies algorithms based on their worst-case or average-case performance. Understanding time complexity helps in evaluating the efficiency of algorithms and choosing the right one for a given problem.

![Time Complexity Graph](https://paper-attachments.dropbox.com/s_2D428973624E7FC84C7D69D11421DE762BEA6B6F3361231FCDCAE0425D14526F_1664885448372_Untitled.drawio+17.png)

### 2) Searching
Searching algorithms are used to find specific data within a structure, such as an array or a list. Common searching techniques include:

- **Linear Search**: Checks each element until the target is found or the list ends (O(n)).
- **Binary Search**: Divides the sorted list in half to locate the target (O(log n)).

### 3) Sorting
Sorting algorithms arrange data in a specific order, typically ascending or descending. Key sorting algorithms include:

- **Bubble Sort**: Repeatedly compares adjacent elements and swaps them if they are in the wrong order.
- **Selection Sort**: Selects the smallest element from the unsorted section and places it in the sorted section.
- **Insertion Sort**: Builds a sorted array by repeatedly picking the next element and inserting it into the correct position.
- **Quick Sort**: Uses a pivot to partition the array into sub-arrays and sorts them recursively.
- **Merge Sort**: Splits the array into halves, sorts them recursively, and merges the sorted halves back together.
